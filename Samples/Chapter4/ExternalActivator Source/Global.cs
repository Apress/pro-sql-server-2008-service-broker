#region Using
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
#endregion

namespace ExternalActivator
{
    /// <summary>
    /// set of all the possible errors that can be generated by the application
    /// </summary>
    public enum Error
    {
        // service install/shutdown related errors
        postInstallProblem = 1,
        installProblem = 2,
        invalidStateOfService = 3,

        // Output Log related errors
        cannotOpenOutputLog = 10,
        noOutputLog = 11,
        cannotRenameOutputLog = 12,
        cannotCloseOutputLog = 13,

        // Init Errors
        initFailed = 20,
        cannotSetCurrentDirectory = 21,
        invalidCommandLineArguments = 22,
        cannotInstallCtrlCHandler = 23,
        anotherCopyOfEAIsAlreadyRunning = 24,

        // Config File related errors
        configFileBadXML = 30,
        invalidConfigFile = 31,
        invalidConfigValues = 32,
        noConfigFile = 33,
        configFileAccessDenied = 34,
        cannotReadConfigFile = -30,

        // Malformed recovery log entry errors
        ERR_HASHTABLE_KEY_NOT_PRESENT = 40,
        ERR_HASHTABLE_KEY_ALREADY_PRESENT = 41,
        ERR_NOT_WELL_FORMED_RECORD = 42,

        // Recovery Log Errors
        badLogFileRecoverNotPossible = 50,
        cannotOpenRecoveryLog = 51,
        cannotCloseRecoveryLog = 52,
        startProcessBadXML = 53,
        damagedRecoveryLog = 54,
        problemAccessingLogFiles = 55,

        // SQL errors
        failedToConnect = 60,
        connectionKilled = 61,
        connectionTimedOut = 62,
        waitforTimedOut = 63,
        invalidQueueName = 64,
        ERR_BAD_EN_MSG = 65,
        failedToCommitTransaction = 66,

        // Create Process Errors
        cannotStartProcess = 70,
        cannotCreateOpenFiles = 71,

        // Misc
        applicationMonitorIsDetaching = 80,
        logingError = 81,
        EAIsExiting = 82,

        // Unexpected
        unexpectedError = 90,
    }

    /// <summary>
    /// Class that represents the exceptions in the application
    /// </summary>
    public class EAException : ApplicationException
    {
        #region Constructors
        /// <summary>
        /// Used to throw a regular exception
        /// </summary>
        /// <param name="message">Text describing the exception</param>
        /// <param name="error">Exception code</param>
        public EAException(string message, Error error) :
            base (message)
        {
            m_error = error;
        }

        /// <summary>
        /// Used to wrap an existing exception in more higher level one.
        /// </summary>
        /// <param name="message">The higher level text</param>
        /// <param name="error">The higher level error</param>
        /// <param name="inner">Caught exception</param>
        public EAException(string message, Error error, Exception inner) :
            base (message, inner)
        {
            m_error = error;
        }
        #endregion

        #region Public methods
        /// <summary>
        /// returns the error code for the current exception
        /// </summary>
        public Error Error
        {
            get { return m_error; }
        }

        public static void Report(Exception e)
        {
            Report(e, false);
        }

        /// <summary>
        /// Reports the exception list to the console or the log file
        /// </summary>
        /// <param name="e">the exception list</param>
        public static void Report(Exception e, bool console)
        {
        	try
        	{
        		string s = "";
	            EAException ea = e as EAException;
	            if (ea != null)
	            {
	            	s += ea.Message;
	                e = ea.InnerException;

	                while (e != null)
	                {
	                    s += " because:\n";
	                    ea = e as EAException;
	                    if (ea != null)
	                    {
	                        s += ea.Message;
	                        e = ea.InnerException;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }

	                if (ea != null)
	                {
	                    s += ".\n";
	                }
	            }

	            if (e != null)
	            {
	            	s += "Unexpected exception was caught: " + e.Message + "\n";
                    s += e.ToString ();
	            }

				Global.WriteException (s, console);
        	}
			catch (Exception)
			{
				// swallow/ignore
			}
        }
        #endregion

        #region Members
        private Error m_error;
        #endregion
    }
    
    /// <summary>
    /// Action to take as specified by command-line arguments
    /// </summary>
    public enum Action
    {
        none,
        run,
        install,
        uninstall,
        help,
    }

    /// <summary>
    /// Command line argument validator
    /// </summary>
    sealed public class ArgumentValidator
    {
        /// <summary>
        /// Checks if arg is of kind: '/' + argName + ':' + data
        /// </summary>
        /// <param name="arg">Argument to check</param>
        /// <param name="argName">Expected argument name</param>
        /// <returns>returns data or null</returns>
        public static string GetStringArgument(string arg, string argName)
        {
            string param = GetSuffix(arg, argName);
            if (param == null || param == String.Empty)
            {
                return null;
            }

            if (param[0] == '=' || param[0] == ':')
            {
                return param.Substring(1);
            }

            return null;
        }

        /// <summary>
        /// Checks if arg is of kind: '/' + argName
        /// </summary>
        /// <param name="arg">Argument to check</param>
        /// <param name="argName">Expected argument name</param>
        /// <returns>true if matches</returns>
        public static bool IsArgument(string arg, string argName)
        {
            string param = GetSuffix(arg, argName);
            if (param == null || param != string.Empty)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="arg"></param>
        /// <param name="argName"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        public static bool GetAndCheckStringArgument(string arg, string argName, ref string data)
        {
            string dataLocal = GetStringArgument(arg, argName);
            if (dataLocal == null)
            {
                return false;
            }
            if (data != null)
            {
                throw new EAException("Duplicate argument: " + argName, Error.invalidCommandLineArguments);
            }
            data = dataLocal;
            return true;
        }

        /// <summary>
        /// Retrieves the suffix of an argument if the prefix is the specified argument name
        /// </summary>
        /// <param name="arg"></param>
        /// <param name="argName"></param>
        /// <returns></returns>
        private static string GetSuffix(string arg, string argName)
        {
            if (arg.Length > argName.Length &&
                (arg[0] == '/' || arg[0] == '-') &&
                arg.Substring(1, argName.Length).ToLower() == argName.ToLower())
            {
                return arg.Substring(argName.Length + 1);
            }

            return null;
        }
    }

    /// <summary>
    /// The class encapsulates information obtained after parsing the command line arguments. 
    /// </summary>
    public class CommandLineArgument
    {
        #region Public methods
        public CommandLineArgument()
        {
            m_action = Action.none;
            m_ntServiceName = null;
            m_password = null;
            m_userName = null;
        }

        /// <summary>
        /// Parses all the arguments.
        /// </summary>
        /// <param name="arguments">The argument list</param>
        public void Parse(
            string[] arguments)
        {
            // no arguments - assume run
            if (arguments.Length == 0)
            {
                Run(arguments);
            }

            //  check the action
            else if (ArgumentValidator.IsArgument(arguments[0], "?") || ArgumentValidator.IsArgument(arguments[0], "help"))
            {
                Help(arguments);
                return;
            }

            else if (ArgumentValidator.GetStringArgument(arguments[0], InstallArgument) != null)
            {
                Install(arguments);
            }
            else if (ArgumentValidator.GetStringArgument(arguments[0], UninstallArgument) != null)
            {
                Uninstall(arguments);
            }
            else
            {
                Run(arguments);
            }
        }
        #endregion

        #region Private methods
        /// <summary>
        /// Handles help option
        /// </summary>
        /// <param name="arguments"></param>
        private void Help(string[] arguments)
        {
            if (arguments.Length != 1)
            {
                throw new EAException("Invalid argument: " + arguments[1], Error.invalidCommandLineArguments);
            }
            m_action = Action.help;
            Global.WriteToConsole("Usage:\n");
            Global.WriteToConsole(
                                "To start it:\n" +
                                "    ExternalActivator\n");
            Global.WriteToConsole(String.Format(
                                "To install it as a Windows NT service:\n" +
                                "    External Activator /{0}:NTServiceName [/{1}:value /{2}:value]\n",
                                InstallArgument, UserNameArgument, PasswordArgument));
            Global.WriteToConsole(String.Format(
                                "To uninstall the NT service:\n" +
                                "    ExternalActivator /{0}:NTServiceName",
                                UninstallArgument));
        }

        /// <summary>
        /// Handles install option
        /// </summary>
        /// <param name="arguments"></param>
        private void Install(string[] arguments)
        {
            m_action = Action.install;
            for (int i = 0; i < arguments.Length; i++)
            {
                if (
                    ArgumentValidator.GetAndCheckStringArgument(arguments[i], InstallArgument, ref m_ntServiceName) ||
                    ArgumentValidator.GetAndCheckStringArgument(arguments[i], UserNameArgument, ref m_userName) ||
                    ArgumentValidator.GetAndCheckStringArgument(arguments[i], PasswordArgument, ref m_password))
                {
                    continue;
                }
                throw new EAException("Invalid argument '" + arguments[i] + "' when installing the external activator", Error.invalidCommandLineArguments);
            }

            if (m_ntServiceName == null)
            {
                throw new EAException("Service name must be specified", Error.invalidCommandLineArguments);
            }

            if (m_userName != null)
            {
                if (m_userName.ToLower() == "networkservice" ||
                    m_userName.ToLower() == "localservice" ||
                    m_userName.ToLower() == "localsystem")
                {
                    if (m_password != null)
                    {
                        throw new EAException("Password cannot be associated with user: " + m_userName, Error.invalidConfigValues);
                    }
                }
                else if (m_password == null)
                {
                    throw new EAException("Password must be specified when user name is specified", Error.invalidCommandLineArguments);
                }
            }
            else if (m_password != null)
            {
                throw new EAException("Password cannot be specified whithout specifying user name", Error.invalidCommandLineArguments);
            }
        }

        /// <summary>
        /// Handles ununstall option
        /// </summary>
        /// <param name="arguments"></param>
        private void Uninstall(string[] arguments)
        {
            m_action = Action.uninstall;
            for (int i = 0; i < arguments.Length; i++)
            {
                if (ArgumentValidator.GetAndCheckStringArgument(arguments[i], UninstallArgument, ref m_ntServiceName))
                {
                    continue;
                }
                throw new EAException("Invalid argument '" + arguments[i] + "' when uninstalling the external activator", Error.invalidCommandLineArguments);
            }

            if (m_ntServiceName == null)
            {
                throw new EAException("Service name must be specified", Error.invalidCommandLineArguments);
            }
        }

        /// <summary>
        /// Handles run option (when no option is specified)
        /// </summary>
        /// <param name="arguments"></param>
        private void Run(string[] arguments)
        {
            m_action = Action.run;

            if (arguments.Length == 0)
            {
                return;
            }

            for (int i = 0; i < arguments.Length; i++)
            {
                if (ArgumentValidator.GetAndCheckStringArgument(arguments[i], RunAsNTServiceArgument, ref m_ntServiceName))
                {
                    continue;
                }
                throw new EAException("Invalid argument '" + arguments[i] + "'", Error.invalidCommandLineArguments);
            }
        }
        #endregion

        #region Properties

        private string m_ntServiceName; // Name of service
        public string NTServiceName
        {
            get { return m_ntServiceName; }
        }

        public bool IsService
        {
            get { return m_ntServiceName != null && m_action == Action.run; }
        }

        private Action m_action; // action to take
        public Action Action
        {
            get { return m_action; }
        }

        private string m_userName; // Username to use for installation purposes
        public string UserName
        {
            get { return m_userName; }
        }

        private string m_password; // Password to use for installation purposes
        public string Password
        {
            get { return m_password; }
        }
        #endregion

        #region Constants
        private readonly static string UserNameArgument = "UserName";
        private readonly static string PasswordArgument = "Password";
        private readonly static string InstallArgument = "Install";
        private readonly static string UninstallArgument = "Uninstall";
        public readonly static string RunAsNTServiceArgument = "RunAsService";
        #endregion
    }


    /// <summary>
    ///	This class encapsulates functioality used for registering
    ///	an input handler with the SetConsoleCtrlHandler Windows API function
    ///	This is mainly used to catch Ctrl-C signals coming from
    ///	the Console if the External Activator is started as an application 
    /// </summary>
    public sealed class ConsoleCtrlC : IDisposable
    {
        #region Public methods
        /// <summary>
        /// Handler to be called when a console event occurs.
        /// </summary>
        /// <param name="consoleEvent"></param>
        /// <returns></returns>
        public delegate bool ControlEventHandler(
            ConsoleEvent consoleEvent); // I	Encapsulates console event that was fired

        /// <summary>
        /// The event that occurred. 
        /// </summary>
        public enum ConsoleEvent
        {
            CtrlC = 0,
            CtrlBreak = 1,
            CtrlClose = 2,
            CtrlLogoff = 5,
            CtrlShutdown = 6
        }

        /// <summary>
        /// Registers a new eventHandler using Windows API function
        /// </summary>
        public ConsoleCtrlC()
        {
            // Save this to a private var so the GC doesn't collect it
            m_eventHandler = new ControlEventHandler(CtrlCHandler);
        }

        /// <summary>
        /// Sets the Console Ctrl Handler. Not done in the constructor because it might return an error
        /// </summary>
        public void SetCtrlHandler()
        {
            if (SetConsoleCtrlHandler(m_eventHandler, true) == false)
            {
                throw new EAException(String.Format("Error {0} while installing Ctlr-C event handler"), Error.cannotInstallCtrlCHandler);
            }
        }
        #endregion

        #region Private methods
        /// <summary>
        /// Calls my dispose function. 
        /// </summary>
        ~ConsoleCtrlC()
        {
            PrivDispose();
        }

        /// <summary>
        ///		Called by CLR this calls my dispose function and suppresses
        ///		finalization to improve performance
        /// </summary>
        public void Dispose()
        {
            PrivDispose();
            GC.SuppressFinalize(this);
        }

        /// <summary>
        ///		Is called whenever a Ctrl-C is caught from the console. Ignored
        /// </summary>
        /// <param name="consoleEvent"></param>
        /// <returns></returns>
        private bool CtrlCHandler(
            ConsoleEvent consoleEvent) // I		Encapsulates the console event received
        {
            return true;
        }

        /// <summary>
        /// Called to release the reset ControlHandler by using SetConsoleCtrlHandler Windows API function. 
        /// </summary>
        private void PrivDispose()
        {
            if (m_eventHandler != null)
            {
                SetConsoleCtrlHandler(m_eventHandler, false);	// no need to check the return value here because going down
                m_eventHandler = null;
            }
        }
        #endregion

        #region External functions
        /// <summary>
        /// Calls the Windows API function SetConsoleCtrlHandler in kernel32.dll
        /// </summary>
        /// <param name="e">The ControlEventHandler to call when a console event is received</param>
        /// <param name="add">Whether to add or remove the ControlEventHandler</param>
        /// <returns>Whether the function succeeded or not</returns>
        [DllImport("kernel32.dll")]
        private static extern bool SetConsoleCtrlHandler(
            ControlEventHandler e,
            bool add);
        #endregion

        #region Members
        private ControlEventHandler m_eventHandler;	// Used to save the function to be called when 
        #endregion
    }

    /// <summary>
    /// Main starting point. Has a collection of all the global components.
    /// Also implements all global functions.
    /// </summary>
	class Global
    {
        #region Public methods
        public static void Exception(int i) { int a = 1 / i; }

        /// <summary>
        ///	Performs initialization of the External Activation. It determines whether the 
        ///	External Activation is started as a service or from the console. If it is started
        ///	from the console, it reads the configuration, reads the log and performs recovery.
        ///	Also registers the Ctrl-C handler and FileWatcher Listener
        /// 
        /// Notes:
        ///		Usage is printed to the console at all times until the External Activator
        ///		knows if it is run as a NT service or not. This is because it expects the External
        ///		Activator to be installed correctly, hence does not expect problems with 
        ///		command-line arguments when started as a service unless someone messes with
        ///		the registry settings. 
        /// </summary>
        /// <param name="args">Command line arguments</param>
        /// <returns>Error code if ends with error</returns>
        [STAThread]
        public static int Main(string[] args)
        {
            ms_appName = System.Reflection.Assembly.GetExecutingAssembly().Location;
            System.Text.UnicodeEncoding encode = new System.Text.UnicodeEncoding();

            ms_appNameBytes = encode.GetBytes(ms_appName);
            ms_outputLogName = ApplicationName + OUTPUTEXT;
            try
            {
                ms_cmdLineArg.Parse(args);

                switch (ms_cmdLineArg.Action)
                {
                    case Action.none:
                        WriteToConsole("Command line arguments are required. Use /? or /help to see the usage.");
                        break;

                    // print the usage text
                    case Action.help:
                        break;

                    // Install the NT Service
                    case Action.install:
                        NTService.Install(ms_cmdLineArg.NTServiceName, ms_cmdLineArg.UserName, ms_cmdLineArg.Password);
                        break;

                    // Uninstall the NT Service
                    case Action.uninstall:
                        NTService.Uninstall(ms_cmdLineArg.NTServiceName);
                        break;

                    // the program is being run and not installed/uninstalled
                    case Action.run:
                        //if the External Activation is started as a NT service
                        if (ms_cmdLineArg.IsService)
                        {
                            NTService.MainFunction(ms_cmdLineArg.NTServiceName);
                        }
                        // if started from the Console or as an Application
                        else
                        {
                            BootExternalActivator();
                        }
                        break;

                    default:
                        throw new EAException("Unexpected action", Error.unexpectedError);
                }
                return 0;
            }
            catch (Exception e)
            {
                DoHardKill(e);
                return 0;
            }
        }

        /// <summary>
        ///	Completes the entire initialization step for the External Activator.
        ///	Common code for service and application
        /// </summary>
        public static void BootExternalActivator()
        {
            try
            {
                // read configuration file and recover from old log
                Initialize();

                // Finish initialization :
                // separated to allow the External Activation 
                // to call common code when started as an application or as an NT Service
                // This is because this phase might take longer since starting up processes might take
                // forever if out of resource conditions happen
                //ConfigurationManager.FinishInitialization(attachProcessTable, last_queuing_order_msg_rcvd, recoveryBeginWrittenToLog);
                Thread startThread = new Thread(new ThreadStart(MainThread));
                startThread.Start();

                if (ms_cmdLineArg.IsService)
                {
                    return;
                }

                // create and register a Ctrl-C handler if the External Activator is not being run as a service
                // required to output ignoring message since startup not complete
                m_cc = new ConsoleCtrlC();
                m_cc.SetCtrlHandler();
            }
            catch (Exception e)
            {
                throw new EAException("Cannot start the External activator", Error.initFailed, e);
            }
            DoCommandProcessing();
        }

        /// <summary>
        /// Shuts the External Activator gracefully.
        /// </summary>
        public static void Cleanup()
        {
            lock (ms_hardKill)
            {
                try
                {
                    WriteStatus("External Activator is shutting down...");
                    // don't care about logging error because it is shutting down

                    // ignore error because going down
                    ms_logMgr.Shutdown();

                    // Detach processes
                    // don't care about logging error because it is shutting down
                    ms_appMonitorMgr.Shutdown();

                    // safe operation because all AMs are detached
                    // so no one will write to the Recovery Log File
                    CloseFiles();

                    WriteInfo("External Activator is shut down");
                    System.Environment.Exit(0);
                }
                catch (Exception e)
                {
                    DoHardKill(e);
                }
            }
        }

        /// <summary>
        /// starts up the listening service thread. The main thread will remain monitoring all the processes
        /// that fall bellow minimum or need to do reporting.
        /// </summary>
        public static void MainThread()
        {
            try
            {
                // Called again here because Configuration Might have changed before the FileSystemWatcher was registered
                // Don't Need the list of AMs to Activate because it will be done later anyway

                WriteDebugInfo(
                    "Re-reading the Configuration File because Configuration File changes might have occurred before FileSystemWatcher was registered");

                ms_configMgr.ReloadActivatorConfiguration();

                // Now that you processes have been activated for all (any) of the Notification messages
                // Start up processes if below minimum

                // Create the NotificationMonitor 
                NotificationService.Start(ms_configMgr);
                Quit();
            }
            catch (Exception e)
            {
                DoHardKill(e);
            }
        }

        public static void ReportApplicationStatus()
        {
            WriteStatus (ms_appMonitorMgr.ToString ());
        }

        public static void ReportConfigStatus()
        {
            WriteStatus (ms_configMgr.ToString ());
        }

        public static void ReportServiceStatus()
        {
            WriteStatus (NotificationService.Report());
        }

        public static void SetDebug(bool isOn)
        {
            ms_debug = isOn;
            ReportDebugStatus();
        }

        public static void ProcessSCCommand (int command)
        {
            switch (command)
            {
                case 128:
                    PrintSCCommandsHelp();
                    break;
                case 129:
                    Global.ReportApplicationStatus();
                    break;
                case 130:
                    Global.ReportConfigStatus();
                    break;
                case 131:
                    Global.ReportServiceStatus();
                    break;
                case 132:
                    Global.RecycleLog();
                    break;
                case 133:
                    Global.SetDebug(true);
                    break;
                case 134:
                    Global.SetDebug(false);
                    break;
                default:
                    Global.WriteStatus("Unknown sc command: '" + command + "'. Issue command '128' for help.");
                    break;
            }
        }

        //	Returns:
        //		TRUE  - if shudown was set before calling the function
        //		FALSE - if shudown was not set before calling the function
        public static bool SetShutdown()
        {
            lock (ms_hardKill)
            {
                if (m_shutdown)
                {
                    return true;
                }

                m_shutdown = true;
                return false;
            }
        }

        public static void DoHardKill(
            Exception e)
		{
            ms_logMgr.UncleanShutdown();
            EAException.Report(e, true);
            WriteError("External activator was abruptly terminated.");
            
            EAException ea = e as EAException;
            if (ea != null)
            {
                System.Environment.Exit((int)ea.Error);
            }

            System.Environment.Exit((int)Error.unexpectedError);
        }

        public static void WriteError(string s)
        {
            WriteToConsole("ERROR:\t" + s);
            WriteToEventLog(s, EventLogEntryType.Error);
            WriteToOutputLog("ERROR", s);
        }

        public static void WriteStatus(string s)
        {
            WriteToConsole(s);
            WriteToOutputLog("STATUS", s);
        }

        public static void WriteInfo(string s)
        {
            WriteToEventLog(s, EventLogEntryType.Information);
            WriteToOutputLog("INFO", s);
        }

        public static void WriteDebugInfo(string s)
        {
            if (ms_debug)
            {
                WriteToOutputLog("DEBUG", s);
            }
        }

        public static void WriteWarning(string s)
        {
            WriteToOutputLog("WARNING", s);
            WriteToEventLog(s, EventLogEntryType.Warning);
        }

        public static void WriteException(string s, bool toConsole)
        {
            if (toConsole)
            {
                WriteToConsole(s);
            }
            WriteToOutputLog("EXCEPTION", s);
        }

        public static void WriteToConsole(string s)
        {
            try
            {
                if (!ms_cmdLineArg.IsService)
                    Console.WriteLine(s);
            }
            catch (IOException)
            {
                // swallow/ignore
            }
        }

        /// <summary>
        /// Recycles the existing log file
        /// </summary>
        public static void RecycleLog()
        {
            lock (ms_hardKill)
            {
                if (ms_outputFile == null)
                {
                    return;
                }

                // Generate the new file name
                DateTime dt = DateTime.Now;
                string ext = "." + dt.Year + "." + dt.Month + "." + dt.Day + "." + dt.Hour + "." + dt.Minute + "." + dt.Second + "." + dt.Millisecond;
                string NewFileName = ms_appName + ext + OUTPUTEXT;
                try
                {
                    // copy the log file to the new log file
                    File.Copy(ms_outputLogName, NewFileName);
                    WriteToConsole("The output file was saved as: " + NewFileName);
                }
                catch (Exception e)
                {
                    WriteToConsole("Cannot save the existing output file as: " + NewFileName + ". The output file is preserved");
                    EAException.Report(e);
                }

                //  truncate the current log file
                ms_outputFile.SetLength(0);
            }
        }
        #endregion

        #region Private methods
        /// <summary>
        ///		Reads the configuration information from the configuration file
        ///     Reads the recovery log and builds a table of orphaned processes with PIDs
        ///         which the External Activator must attempt to attach to
        ///     Attempts to attach to those processes
        ///     Set a file watcher for the configuration file
        /// </summary>
        private static void Initialize()
        {
            try
            {
                ms_outputFile = File.Open(ms_outputLogName, FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read);
                ms_outputFile.Seek(0, SeekOrigin.End);
                ms_outputStream = new StreamWriter(ms_outputFile);
            }
            catch (Exception e)
            {
                WriteError("Cannot create or open for writing the Output log file " + ms_outputLogName);
                throw new EAException("Cannot create or open for writing the Output log file " + ms_outputLogName, Error.cannotOpenOutputLog, e);
            }
            WriteStatus("--- Output logging has started ---");

            // Read configuration information from the configuration file
            // if the configuration file is not specified, use a default configuration file
            WriteStatus("External Activator is initializing...");

            try
            {
                // Read Log and Recover
                Hashtable pidHashTable = null;
                ms_logMgr.RunRecovery(out pidHashTable);

                // initialize the applicaton monitor table
                ms_appMonitorMgr.AttachToProcesses(pidHashTable);

                // initalizes the configuration manager
                ms_configMgr.Initialize();

                WriteStatus("External Activator initialization completed.");
            }
            catch (Exception e)
            {
                throw new EAException("Cannot initialize the External activator", Error.initFailed, e);
            }
        }

        /// <summary>
        /// Closes all the global files
        /// </summary>
        private static void CloseFiles()
        {
            lock (ms_hardKill)
            {
                if (ms_outputStream != null)
                {
                    ms_outputStream.Close();
                    ms_outputStream = null;
                }

                if (ms_outputFile != null)
                {
                    ms_outputFile.Close();
                    ms_outputFile = null;
                }

                if (ms_eventLog != null)
                {
                    ms_eventLog.Close();
                    ms_eventLog = null;
                }
            }
        }

        /// <summary>
        /// Reports the debugging status
        /// </summary>
        private static void ReportDebugStatus()
        {
            if (ms_debug)
            {
                WriteStatus("Debug information will be reported in the output log.");
            }
            else
            {
                WriteStatus("Debug information will not be reported in the output log.");
            }
        }

        /// <summary>
        /// Shows the list of available commands and their description
        /// </summary>
        private static void PrintCommandsHelp()
        {
            WriteToConsole("Help|?    - displays this list");
            WriteToConsole("Status    - displays the current status of each configured application");
            WriteToConsole("Config    - displays the current configuration for this activator (in memory)");
            WriteToConsole("Activator - reports the overall status for the activator itself");
            WriteToConsole("Recycle   - recycles the output log file");
            WriteToConsole("Debug     - displays if debug information is reported in the output log");
            WriteToConsole("Debug on|off - controls the report of debug information in the output log");
            WriteToConsole("Quit      - shuts down this activator");
        }

        /// <summary>
        /// Shows the list of available SC commands and their description
        /// </summary>
        private static void PrintSCCommandsHelp()
        {
            WriteStatus("SC command list\n" +
                "128 (Help)      - displays this list\n" + 
                "129 (Status)    - displays the current status of each configured application\n" +
                "130 (Config)    - displays the current configuration for this activator (in memory)\n" +
                "131 (Activator) - reports the overall status for the activator itself\n" +
                "132 (Recycle)   - recycles the output log file\n" +
                "133 (Debug on)  - turns on the report of debug information in the output log\n" +
                "134 (Debug off) - turns off the report of debug information in the output log");
        }

        /// <summary>
        /// Quits the application
        /// </summary>
        private static void Quit ()
        {
            if (SetShutdown () == false)
            {
                Cleanup ();
            }
        }

        /// <summary>
        /// Manages the commands when external activator is not running as service
        /// </summary>
        private static void DoCommandProcessing()
        {
            WriteToConsole("Commands");
            PrintCommandsHelp();
            WriteToConsole("Entering command mode.");

            while (true)
            {
                Console.Write("\nExternal Activator> ");
                string commandLine = Console.ReadLine();
                if (commandLine == null)
                {
                    continue;
                }

                commandLine = commandLine.ToLower().Trim();
                string command = commandLine;
                string args = "";
                int commandEnd = commandLine.IndexOf(' ');
                if (commandEnd != -1)
                {
                    args = commandLine.Substring (commandEnd).Trim ();
                    command = commandLine.Substring(0, commandEnd);
                }

                //  commands without arguments
                if (args == "")
                {
                    if (command == "help" || command == "?" || command == "h")
                    {
                        PrintCommandsHelp();
                        continue;
                    }

                    if (command == "quit" || command == "q")
                    {
                        Quit();
                        break;
                    }

                    if (command == "status" || command == "s")
                    {
                        ReportApplicationStatus();
                        continue;
                    }

                    if (command == "config" || command == "c")
                    {
                        ReportConfigStatus();
                        continue;
                    }

                    if (command == "recycle" || command == "r")
                    {
                        RecycleLog();
                        continue;
                    }

                    if (command == "activator" || command == "a")
                    {
                        ReportServiceStatus();
                        continue;
                    }

                    if (command == "debug" || command == "d")
                    {
                        ReportDebugStatus();
                        continue;
                    }
                }
                // commands with arguments
                else
                {
                    if (command == "debug" || command == "d")
                    {
                        if (args == "on")
                        {
                            SetDebug(true);
                            continue;
                        }

                        if (args == "off")
                        {
                            SetDebug(false);
                            continue;
                        }
                    }
                }

                NTService.Execute(commandLine, 0);
                // WriteToConsole("Unknown command '" + commandLine + "' use 'help' for the list of valid commands");
            }
        }

        /// <summary>
        /// Writes to the event log
        /// </summary>
        /// <param name="s">Text to write</param>
        /// <param name="evType">Type of the entry</param>
        private static void WriteToEventLog(string s, EventLogEntryType evType)
        {
            lock (ms_hardKill)
            {
                EventLog.WriteEntry(Path.GetFileNameWithoutExtension(ApplicationName), s, evType, 0, 0, ms_appNameBytes);
            }
        }

        /// <summary>
        /// Writes to the application output log
        /// </summary>
        /// <param name="prefix">Text prefix. It gets put on every line.
        /// For all lines but first the prefix is extened with ' DETAILS'</param>
        /// <param name="s">Text to write</param>
        private static void WriteToOutputLog(string prefix, string s)
        {
            try
            {
                lock (ms_hardKill)
                {
                    if (ms_outputStream != null)
                    {
                        StringReader reader = new StringReader(s);
                        string line = reader.ReadLine();
                        ms_outputStream.WriteLine(DateTime.Now.ToString() + "\t" + prefix + ":\t" + line);
                        ms_outputStream.Flush();
                        for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        {
                            ms_outputStream.WriteLine(DateTime.Now.ToString() + "\t" + prefix + " DETAILS:\t" + line);
                            ms_outputStream.Flush();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                WriteToConsole("Output Logging failed.\nException Details: " + e.Message);
                throw e;
            }
        }
        #endregion

        #region Properties
        private static bool m_shutdown = false; // indicates the state of the External Activator (shutting down/Not shutting down)
        static public bool Shutdown
        {
            get { lock (ms_hardKill) return m_shutdown; }
        }

        private static LogManager ms_logMgr = new LogManager ();
        static public LogManager LogMgr
        {
            get { return ms_logMgr; }
        }

        private static ApplicationMonitorManager ms_appMonitorMgr = new ApplicationMonitorManager();
        public static ApplicationMonitorManager AppMonitorMgr
        {
            get { return ms_appMonitorMgr; }
        }

        private static string ms_appName = null;
        public static string ApplicationName
        {
            get { return ms_appName; }
        }

        public static bool IsNTService
        {
            get { return ms_cmdLineArg.IsService; }
        }
        #endregion

        #region Members
        private static EventLog ms_eventLog = null;
        private static FileStream ms_outputFile = null;
		private static StreamWriter ms_outputStream = null;
        private static string ms_outputLogName = null;
        private static CommandLineArgument ms_cmdLineArg = new CommandLineArgument(); // command-line arguments
        private static ConfigurationManager ms_configMgr = new ConfigurationManager ();
        private static ConsoleCtrlC m_cc = null; // Listens to Ctrl-C events from the console
        private static bool ms_debug = false;
        private static byte[] ms_appNameBytes = null;

        private static object ms_hardKill = new object(); // to make sure only one HardKill is happening at a time
                                                         // and to synchronize access to the Output Log
        #endregion
		
        #region Constants
        public static readonly int MAX_WAITING_TIME = 60000; // 60 seconds = 1 minute
		public static readonly int TIME_WAIT_TO_BE_HARD_KILLED = 100000; // 100 seconds (some huge time value)

		public static readonly int CONSOLE = 0x00000001; // 0001
		public static readonly int OUTPUTLOG = 0x00000002; // 0010
		public static readonly int EVENTLOG_INF = 0x00000004; // 0100
		public static readonly int EVENTLOG_ERR = 0x00000008; // 1000

        private static readonly string OUTPUTEXT = ".log";
        #endregion
    }
} 
